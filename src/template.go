package src

var RpcTemplate = `// Code generated by go2rpcx. DO NOT EDIT.
// source: {{.FileName}}

package {{.PackageName}}

import (
	context "context"
	client "github.com/smallnest/rpcx/client"
	server "github.com/smallnest/rpcx/server"

	{{- range  $v :=  .Imports}}
	{{$v}}
	{{- end}}
)
{{range .Messages}}
type {{.Name}} struct {
    {{- range .MessageFields}}
    {{.FieldName}} {{.FieldType}} {{.FieldTag}} {{.Comment}}
    {{- end}}
}
{{end}}
// ======================================================
// This following code was generated by rpcx.

const (
	ServiceNameOf{{.Service.Name}} = "{{.Service.Name}}"
)

//================== interface skeleton ===================
type I{{.Service.Name}}Service interface {
	{{- range .Service.ServiceFunctions}}
	{{.Comment}}
	{{.Name}}(ctx context.Context, args *{{.ParamType}}, reply *{{.ResultType}}) (err error)
	{{- end}}
}

//================== server skeleton ===================
type {{.Service.Name}}Impl struct{}

// ServerFor{{.Service.Name}} starts a server only registers one service.
// You can register more services and only start one server.
// It blocks until the application exits.
func ServerFor{{.Service.Name}}(addr string, plugin server.Plugin) error {
	s := server.NewServer()
	s.Plugins.Add(plugin)
	s.RegisterName(ServiceNameOf{{.Service.Name}}, new({{.Service.Name}}Impl), "")
	return s.Serve("tcp", addr)
}

func Register{{.Service.Name}}Server(s *server.Server, srv I{{.Service.Name}}Service, metadata string) error {
	return s.RegisterName(ServiceNameOfUser, srv, metadata)
}

{{- range .Service.ServiceFunctions}}

func (s *{{$.Service.Name}}Impl) {{.Name}}(ctx context.Context, args *{{.ParamType}}, reply *{{.ResultType}}) (err error) {
	// TODO: add business logics

	// TODO: setting return values
	*reply = {{.ResultType}}{}

	return nil
}
{{- end}}

//================== client stub ===================
// {{.Service.Name}}Client is a client wrapped XClient.
type {{.Service.Name}}Client struct {
	xclient client.XClient
}

// New{{.Service.Name}}Client wraps a XClient as {{.Service.Name}}Client.
// You can pass a shared XClient object created by NewXClientFor{{.Service.Name}}.
func New{{.Service.Name}}Client(xclient client.XClient) *{{.Service.Name}}Client {
	return &{{.Service.Name}}Client{xclient: xclient}
}

// NewXClientFor{{.Service.Name}} creates a XClient.
// You can configure this client with more options such as etcd registry, serialize type, select algorithm and fail mode.
func NewXClientFor{{.Service.Name}}(discovery client.ServiceDiscovery) (client.XClient, error) {
	opt := client.DefaultOption
	xclient := client.NewXClient(ServiceNameOf{{.Service.Name}}, client.Failtry, client.RoundRobin, discovery, opt)

	return xclient, nil
}

{{- range .Service.ServiceFunctions}}

func (c *{{$.Service.Name}}Client) {{.Name}}(ctx context.Context, args *{{.ParamType}}) (reply *{{.ResultType}}, err error) {
	reply = &{{.ResultType}}{}
	err = c.xclient.Call(ctx, "{{.Name}}", args, reply)
	return reply, err
}
{{- end}}

//================== oneclient stub ===================
// {{.Service.Name}}OneClient is a client wrapped oneClient.
type {{.Service.Name}}OneClient struct {
	serviceName string
	oneclient   client.OneClient
}

// New{{.Service.Name}}OneClient wraps a OneClient as {{.Service.Name}}OneClient.
// You can pass a shared OneClient object created by NewOneClientFor{{.Service.Name}}.
func New{{.Service.Name}}OneClient(oneclient client.OneClient) *{{.Service.Name}}OneClient {
	return &{{.Service.Name}}OneClient{
		serviceName: ServiceNameOf{{.Service.Name}},
		oneclient:   oneclient,
	}
}

{{- range .Service.ServiceFunctions}}

func (c *{{$.Service.Name}}OneClient) {{.Name}}(ctx context.Context, args *{{.ParamType}}) (reply *{{.ResultType}}, err error) {
	reply = &{{.ResultType}}{}
	err = c.oneclient.Call(ctx, c.serviceName, "{{.Name}}", args, reply)
	return reply, err
}
{{- end}}
`