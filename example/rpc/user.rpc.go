// Code generated by go2rpcx. DO NOT EDIT.
// source: user.go

package rpc

import (
	context "context"
	client "github.com/smallnest/rpcx/client"
	server "github.com/smallnest/rpcx/server"
)

type Request struct {
    Name string `json:"name"` // 用户名
}

type Response struct {
    Result string `json:"result"` // 返回结果
}

// ======================================================
// This following code was generated by rpcx.

const (
	ServiceNameOfUser = "User"
)

//================== interface skeleton ===================
type IUserService interface {
	// 获取用户
	GetUser(ctx context.Context, args *Request, reply *Response) (err error)
}

//================== server skeleton ===================
type UserImpl struct{}

// ServerForUser starts a server only registers one service.
// You can register more services and only start one server.
// It blocks until the application exits.
func ServerForUser(addr string, plugin server.Plugin) error {
	s := server.NewServer()
	s.Plugins.Add(plugin)
	s.RegisterName(ServiceNameOfUser, new(UserImpl), "")
	return s.Serve("tcp", addr)
}

func RegisterUserServer(s *server.Server, srv IUserService, metadata string) error {
	return s.RegisterName(ServiceNameOfUser, srv, metadata)
}

func (s *UserImpl) GetUser(ctx context.Context, args *Request, reply *Response) (err error) {
	// TODO: add business logics

	// TODO: setting return values
	*reply = Response{}

	return nil
}

//================== client stub ===================
// UserClient is a client wrapped XClient.
type UserClient struct {
	xclient client.XClient
}

// NewUserClient wraps a XClient as UserClient.
// You can pass a shared XClient object created by NewXClientForUser.
func NewUserClient(xclient client.XClient) *UserClient {
	return &UserClient{xclient: xclient}
}

// NewXClientForUser creates a XClient.
// You can configure this client with more options such as etcd registry, serialize type, select algorithm and fail mode.
func NewXClientForUser(discovery client.ServiceDiscovery) (client.XClient, error) {
	opt := client.DefaultOption
	xclient := client.NewXClient(ServiceNameOfUser, client.Failtry, client.RoundRobin, discovery, opt)

	return xclient, nil
}

func (c *UserClient) GetUser(ctx context.Context, args *Request) (reply *Response, err error) {
	reply = &Response{}
	err = c.xclient.Call(ctx, "GetUser", args, reply)
	return reply, err
}

//================== oneclient stub ===================
// UserOneClient is a client wrapped oneClient.
type UserOneClient struct {
	serviceName string
	oneclient   *client.OneClient
}

// NewUserOneClient wraps a OneClient as UserOneClient.
// You can pass a shared OneClient object created by NewOneClientForUser.
func NewUserOneClient(oneclient *client.OneClient) *UserOneClient {
	return &UserOneClient{
		serviceName: ServiceNameOfUser,
		oneclient:   oneclient,
	}
}

// NewOneClientForUser creates a OneClient.
// You can configure this client with more options such as etcd registry, serialize type, select algorithm and fail mode.
func NewOneClientForUser(discovery client.ServiceDiscovery) (*client.OneClient, error) {
	opt := client.DefaultOption
	oneclient := client.NewOneClient(client.Failtry, client.RoundRobin, discovery, opt)

	return oneclient, nil
}

func (c *UserOneClient) GetUser(ctx context.Context, args *Request) (reply *Response, err error) {
	reply = &Response{}
	err = c.oneclient.Call(ctx, c.serviceName, "GetUser", args, reply)
	return reply, err
}
